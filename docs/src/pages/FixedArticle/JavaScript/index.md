# javaScript数据中的类型
## 基本数据类型
- Number
- String
- Bigint
- Boolean
- Symbol
- Null
- Undefined
## 引用数据类型
复杂类型统称为Object，主要是以下三种
- Object
- Array
- Function
## 其他类型
- Date
- RegEXP
- Map
- Set等
## 存储区别
- 基本类型存储在栈中
- 引用类型的对象存储在堆中
# 数组的常用方法（操作、排序、转换、迭代）
## 增删改查
### 增加  前三者会对原数组产生影响(改变)，第四个不会对原数组产生影响(不变)
 - push()      **接受一个或者多个参数将其添加到数组末尾，返回数组的最新状态**

 - unshift()  **接受一个或者多个参数将其添加到数组开头，返回数组的最新状态**

 - splice()   **传入三个参数，开始位置，0（要删除元素的个数），插入的元素，返回一个空数组**

 - concat()   **会创建一个副本，然后再把它自己的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组**

### 删除   前三者会对原数组产生影响(改变)，第四个不会对原数组产生影响（不变）
- pop()    **删除数组最后一项，并返回被删除的项**

- shift()  **删除数组的第一项，并返回被删除的项**

- splice()  **传入两个参数，开始位置、删除元素的数量，返回包含删除元素的数组**
  
- slice   **用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原数组。传入两个参数：第一个参数是开始索引，第二个参数是结束索引(但不包括该索引)**

### 修改
- splice()   **传入三个参数，开始位置，0（要删除元素的个数），插入的元素，返回一个空数组**
### 查找
- indexOf() **返回要查找元素在对应数组中的下标，没有返回-1**
  
- includes()  **查找参数是否包含在当前数组中，找到返回true 否则返回 false**
-  find()    **传入一个函数，函数包含三个参数，第一个参数为item，第二个参数是index，第三个参数是array（数组本身），如果满足条件 就返回满足条件的item**
```js
const people = [
    {
        name: "Matt",
        age: 27
    },
    {
        name: "Nicholas",
        age: 29
    }
];
people.find((element, index, array) => element.age < 28) // // {name: "Matt", age: 27}
```

## 排序
- reverse()  ***将数组元素方向反转***
- sort()   **默认按照字母升序排序，或者数字升序排序。也可以接受一个函数**
```js
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
let values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); // 0,1,5,10,15
```

## 转换方法
- join()  接受一个参数，即数组每一项之间的分隔符，返回包含所有项的字符串，（去掉[] 并转换为字符串）

## 迭代方法
- some()   **接受一个函数 (item,index,arr)=>item>1 设置一个表达式，依次对数组的每一个值进行比较，只要有一个满足就返回true，否则返回false** 
  
- every()   **接受一个函数 (item,index,arr)=>item>1 设置一个表达式，依次对数组的每一个值进行比较，必须每一项都满足才会返回true，否则返回false** 

- forEach() **接受一个函数 (item,index,arr)=>{} 进行循环，然后自定义功能** 
- filter()   **接受一个函数 (item,index,arr)=>item>1 函数返回true的项会组成一个数组最后返回**
- map()   **接受一个函数 (item,index,arr)=>item>1 返回每次函数调用的结果组成的数组**

# 字符串常用品方法 （操作、转换、模板匹配）

## 操作（增删改查）

### 增加 (不会对原有字符串进行改变)
- concat() **用于将一个或多个字符串拼接在一起组成一个新的字符串** 
### 删除 (不会对原有字符串进行改变)
这三个方法都返回调他们的字符串的一个子字符串，并且都接受一个或两个字符串 不过需要注意的是，subsrt在传入两个参数时候，是包含第二个参数在字符串中的下标位置的
- slice()   
- substr()
- substring()
```js
let stringValue = "hello world";
console.log(stringValue.slice(3)); // "lo world"
console.log(stringValue.substring(3)); // "lo world"
console.log(stringValue.substr(3)); // "lo world"
console.log(stringValue.slice(3, 7)); // "lo w"
console.log(stringValue.substring(3,7)); // "lo w"
console.log(stringValue.substr(3, 7)); // "lo worl"
```
### 修改 (不会对原有字符串进行改变)
- trim()、trimLeft()、trimRight()  **分别表示：删除开头和结尾的空格、删除开头的空格、删除结尾的空格、 并返回一个新的字符串**

- repeat()  **接受一个整数参数，表示将当前字符串复制参数倍，组成一个的字符串并返回**

- padStart()、padEnd() **接受一个或者两个参数,第一个参数是复制多少倍，第二个参数是要被复制的值，只有一个参数的话默认第二个参数为空格，start是添加到开头，end则是结尾**

- toLowerCase()、toUpperCase() **两个方法是对字符串进行大小写转换，前者是将大写转换为小写，后者是将小写转换为大写**
### 查询
除了通过索引的方式可以进行查询以外还包括以下方法：

- charAt() **接受一个参数，返回指定位置的字符**

- indexOf() **接受一个参数，查询字符串中是否存在，如果存在返回下标，不存在返回-1**

- startWith()  **接受一个参数，参数必须是字符串，查询字符串是否是以参数作为开头的，如果是就返回true，否则返回false**

- endsWith()  **接受一个参数，参数必须是字符串，查询字符串是否是以参数作为结尾的，如果是就返回true，否则返回false**

- includes() **接受一个参数，参数必须是字符串，查询字符串中是否包含参数，如果有就返回true，否则返回false**

## 转换方法
- split **把字符串按照指定的分隔符，拆分成数组的每一项，如果传入空字符串，则每一个字符都会被拆解成数组的每一项**

## 模板匹配方法
针对正则表达式，字符串设计了几个方法：

- match()  **接受一个参数，可以是一个正则表达式，也可以是一个RegExp对象，返回一个数组**

- search() **接受一个参数，可以是一个正则表达式，也可以是一个RegExp对象,如果找到则返回匹配索引，否则返回-1**
  
- replace() **接受两个参数，第一个参数为匹配的内容，第二个参数则是要替换的元素**

# 类型转换

常见的类型转换
- 强制类型转换(显式转换)
- 自动转换（隐式转换）

## 显式转换
- Number()   **将参数值转换为数字**
- parseInt() **和Number类似，但是只要是以数值开头的都能转换，遇到非数字的会直接返回已经被转换的**
- String()    **将参数转换为字符串**
- Boolean()   **将参数转换为布尔值**

## 隐式转换
隐式转换发生的两种场景
- 比较运算(== 、!=、>、< ) if、 while 需要布尔值的地方
- 算术运算(+、-、*、/、% )

### 自动转换为布尔值
- undefined
- null
- false
- +0
- -0
- NaN
- ""
  除了上面的会被转换为false其他情况会被转换为true
### 自动转换为字符串
- 规则：先将复合类型的值转换为原始类型的值，再将原始类型的值转换为字符串，通常会出现在连接符号"+" 运算中，并且一方为字符串
### 自动转换为Number
- 除了“+”有可能把运算符转换为字符串，其他运算符都会把运算子 自动转换为数值

# ==和===
## 等于操作符 （==）
等于操作符(==)在比较中会先进行类型转换，再确定操作数是否相等，并且遵循一下规则：
- 两个都为简单类型，字符串和布尔值都会转换为数值，再进行比较
- 简单类型和引用类型进行比较，对象则会转换成其原始类型的值，在进行比较
- 如果两个都是引用类型，则比较它们是否指向同一个对象
- Null和Undefined相等
- 存在NaN则返回false
## 全等操作符(===)
- 即在等于操作符（==）的基础之上添加了类型判断，并且不允许进行类型转换

## 区别
- 相等操作符（==）会做类型转换再进行比较，全等操作符（===）则不允许类型转换
- null与Undefined 相等操作符（==）为true 全等操作符(===)为false

# 深拷贝和浅拷贝的区别，以及如何实现一个深拷贝

- 需要明白一点，浅拷贝只存在于引用对象中， 基本数据类型不存在浅拷贝
  
## 什么是浅拷贝
- 浅拷贝指的是创建新的数据，这个数据有着原始数据是性质的一份精确拷贝，如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址
- 浅拷贝是拷贝一层，深层次的引用类型则共享内存地址
####   在js中存在浅拷贝的现象有：
- Object.assign
- slice()  concat()
-  使用扩展运算符实现的复制

## 什么是深拷贝
- 深拷贝开辟一个新的栈，两个对象属性完全相同，但是对应两个不同的地址，修改一个对象的属性，不会改拜年另一个对象的属性
 常见的深拷贝方式有：
 - _.cloneDeep()
 - JQuery.extend()
 - JSON.stringify()
 - 手写一个循环递归
## 总结
- 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象只想同一个地址
- 深拷贝是递归拷贝深层次，属性为对象时，深拷贝时新开栈，两个对象指向不同的地址

# 闭包
## 解释
 存在子父级函数，子函数访问父级函数的变量就会产生闭包
## 使用场景
- 创建私有变量
- 延长变量的生命周期
# 作用域链
## 作用域
- 作用域：变量（变量作用域又称上下文）或函数生效的区域集合 
作用域的划分：
- 全局作用域：**任何不再函数或是大括号“{}”中声明的变量，都属于全局作用域，全局作用域可以在任意地方被访问**
- 块级作用域：**ES6引入了let和const关键字，和var不同，在大括号内部“{}”使用let和const声明的变量和就存在于块级作用域内，大括号外部不能访问**
- 函数作用域：**函数作用域也叫局部作用域，如果一个变量实在函数内部声明的它就在一个函数作用域下面，这些变量就只能在函数内部被访问，函数外部则不能访问**
## 词法作用域
词法作用域又叫静态作用域，变量被创建时就已经确定好了，而非执行阶段确定的。也就是说我们写好代码时它的作用域就已经确定了，JavaScript遵循的就是词法作用域
### 作用域链
当在JavaScript中使用一个变量时，首先js引擎会尝试在当前作用域内查找改变量，如果没有找到，他会向当前作用域的上层作用域，也就是外部去寻找，以此类推，直到全局作用域，如果在全局作用域找不到，那么直接报错，is not defined  这种一层一层查找变量规则的机制，就是作用域连
# 原型，原型链
## 原型
- js是一种基于原型的语言，每个对象都拥有一个原型对象
- 当试图访问一个变量上的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象原型的原型，依次层层向上搜索，直到找到一个名称匹配的属性或者到达原型链的末尾
- 准确的说这些属性和方法定义在Object的构造器函数只上的Prototype属性上，而非实例对象本身
函数可以有属性，每一个函数都有一个特殊的属性叫作“原型”（prototype） 原型对象上有一个自有属性 constructor，这个属性指向该函数
## 原型链
- 原型对象可能也拥有自己的原型，并从中继承方法和属性，一层一层，以此类推，这种关系尝尝被称之为原型链，它解释了一个对象为什么会拥有定义在其他对象上的属性和方法
- 在对象实例和他的构造器之间建立了一个链接（__proto__属性，是构造函数的prototype派生的），之后通过上溯原型链，在构造器中找到这些属性和方法
### 分析 （首先存在构造函数Person）
- 构造函数Person存在原型对象Person.prototype
- 构造函数生成实例对象person，person的__proto__指向构造函数Person的原型对象 也就是指向Person.prototype
- Person.prototype的__proto_指向内置对象，因为Person.prototype是个对象，默认是由Object函数作为类创建的，而Object.prototype 为内置对象
- Person的__proto__指向内置匿名函数anonymous，因为Person是个函数对象，默认由Function作为类创建
- Function.prototype和Function.__proto__同时指向内置匿名函数anonymous，这样原型链的终点就是null
## 总结
概念：
- __proto__作为不同对象之间的桥梁，用来指向创建它的构造函数的原型对象的
- 每个对象的__proto__都是指向它的构造函数的原型对象 prototype的
```js
person1.__proto__===Person.prototype
```
- 构造函数是一个函数对象，是通过Function构造器产生的
```js
Person.__proto__===Function.prototype
```
- 所有的构造器都是函数对象，函数对象都是由Function构造产生的
```js
Object.__proto__===Function.prototype
```
- 原型对象本身是一个普通对象，而普通对象的构造函数都是Object
```js
Person.prototype.__proto__===Object.Prototype
```
- Function的原型同样是一个普通对象，所以__proto__也会指向Object的原型
```js
Function.prototype.__proto__===Object.prototype
```
- Object的原型也有__proto__属性，指向null，null是原型链的顶端
```js
Object.prototype.__proto__ === null
```
总结：
- 一切对象都继承自Object对象，Object对象直接继承根源对象 null
- 一切函数对象(包括object对象)，都继承自Function 对象
- Object对象直接继承自Function对象
- Function对象的__prop__会指向自己的原型对象，最终还是继承自Object对象
 
# 继承
## 继承是什么？
- 继承是面向对象软件的一个概念，如果一个类别B继承自另一个类别A，就把B称为A的子类， 而把A称之为B的父类别，也可以称A是B的超类
### 优点
- 继承可以使子类具有父类的所有方法和属性，但不需要重新编码，
- 在子类继承父类时，可以对属性和方法重新进行定义
- 可以批量生产处具有父类方法和属性的子类
## 实现方式
- 原型链继承
- 构造函数继承（借助call）
- 组合继承
- 原型式继承
- 寄生式继承
- 寄生组合式继承 
# 执行上下文和执行栈
## 执行上下文
- 执行上下文是对JavaScript代码执行环境的一种抽象概念，也就是说只要有JavaScript代码运行，那么他就一定是运行在执行上下文中
执行上下文分为三种：
- 全局执行上下文：只有一个，在浏览器中就是window对象，在node中是global
- 函数执行上下文 ：存在无数个，只有函数被调用时才会创建，每次调用函数都会创建一个新的执行上下文
- Eval函数执行上下文：指的是运行在函数Eval的代码，很少用并且不建议使用
## 生命周期
- 执行上下文的生命周期包含三个阶段：创建阶段 - 执行阶段 - 回收阶段
### 创建阶段 指函数被调用，但未执行任何内部代码之前
创建阶段做了三件事：
- 确定this值，也被称之为 This Binding
- Lexical(词法环境) 组件被创建 
- VariableEnvironment（变量环境）词法被创建
执行阶段
- 在这个阶段，执行变量赋值、代码执行
- 如果JavaScript引擎在源代码中声明的实际位置找不到变量的值，那么将其分配为Undefined
回收阶段
- 执行上下文出栈等待虚拟机回收执行上下文
## 执行栈
- 执行栈，也叫调用栈，具有LIFO(后进先出) 结构，用于存储代码在执行期间创建的所有执行期上下文
- 当JavaScript引擎开始执行你的第一行脚本代码时，他就会创建一个全局执行上下文，然后将它压到执行栈中
- 每当引擎碰到一个函数的时候，他就会创建一个函数执行上下文，然后将这个函数执行上下文压到执行栈中
- js引擎会执行位于执行栈栈顶的执行上下文（一般是函数执行上下文），当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个上下文
  
# javaScript中的事件模型
## 事件与事件流
javascript中的事件，可以理解就是在HTML文档或者浏览器中发生的一种交互操作，使得网页具备互动性，常见的有加载时间、鼠标事件、自定义事件等

由于DOM是一个树结构，如果在父子节点绑定事件的时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念

事件流都会经历三个阶段：
- 事件捕获阶段
- 处于目标阶段
- 事件冒泡阶段 
 ### 事件冒泡
 事件冒泡是从下往上的传播方式，由最具体的元素（触发节点）然后逐渐向上传播到最不具体的那个节点，也就是DOM中最高层的父节点

## 事件模型
事件模型可以分为三种：
- 原始事件模型（DOM0级）
- 标准事件模型（DOM2级）
- IE事件模型（基本不用）
  
### 原始事件模型
事件绑定监听函数比较简单，有两种方式：
- HTML代码中直接绑定
- 通过JS代码绑定
#### 特性
- 绑定速度快
      DOM0级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定的速度太快，可能页面还未完全加载出来，以至于事件可能无法正常执行
- 只支持冒泡，不支持捕获
- 同一个类型的的事件只能绑定一次
- 删除DOM0级事件  btn.onclick=null
### 标准事件模型
在该事件模型中，一次事件共有三个过程
- 事件捕获阶段：事件从document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行
- 事件处理阶段：事件到达目标元素，触发目标元素的监听函数
- 事件冒泡阶段：事件从目标元素冒泡到document，一次检查经过的节点是否绑定了事件监听函数，如果有，则执行
### IE事件模型
IE事件模型共有两个过程：
- 事件处理阶段： 事件到达目标元素，触发目标元素的监听函数
- 事件冒泡阶段：事件从目标元素冒泡到document，一次检查应该的节点是否绑定了事件监听函数，如果有，则执行
# typeof和instanceof
## typeof
typeof 操作服返回一个字符串，表示未经计算的操作数的类型
- 使用方法如下：
```js
typeof a
typeof(a)
```
a 表示对象或原始值的表达式，其类型将被返回
#### 存在的问题
- 引用数据类型如果用typeof来判断的话，除了function会被识别以外，其他都返回object
- typeof null  返回的为object
## instanceof
instanceof运算符用于检测构造函数的prototype 属性是否出现在某个实例对象的原型链上

## 区别
typeof和instanceof都是判断数据类型的方法，区别如下：
- typeof会返回一个变量的基本类型，instanceof返回的是一个布尔值
- instanceof可以准确地判断负责引用数据类型，但是不能正确判断基础数据类型
- 而typeof也存在弊端，他虽然可以判断基础数据类型（null除外），但是引用数据类型中，除了function之外，其他的也无法判断
- 所以如果需要进行类型判断，建议使用Object.prototype.toString.call()方法来进行判断
# 事件代理及其应用场景
## 什么是事件代理
- 事件代理，通俗的讲，就是把一个元素的响应事件（click、keydown 。。。。。）的函数委托到另一个元素上，前面讲到，事件流都会经过三个阶段：捕获阶段->目标阶段->冒泡阶段，而事件委托就是在冒泡阶段完成的
- 事件委托，会把一个或者一组元素的事件委托到他的父层或者更外层的元素上，真正绑定事件的是外层元素，而不是目标元素。当事件相应到目标元素上时，会通过冒泡事件极致从而触发他的外层元素上的绑定事件上，然后在外层元素上去执行函数
## 应用场景
当一个元素内存在大量子元素，并且子元素执行的事件大部分是相同的，这个时候我门就可以通过事件冒泡将事件委托到父元素上，从而减少重复代码的书写

## 总结
-  适合事件委托的事件有：click、mousedown、mouseup、keydown、keyup、keypress、
从上面应用场景中，我们就可以看到使用事件委托存在的两大优点：
- 减少整个页面所需的内存，提升整体性能
- 动态绑定，减少重复工作
使用事件委托的局限性：
- focus、blur这些事件没有冒泡机制，所以无法进行委托绑定事件
- mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗比较高，因此也不适合用事件委托
- 如果把所有事件都用事件代理，可能会出现事件误判，即本不应该被触发的事件被绑定上了事件

# new 操作符
## 什么是new 操作符
在javascript中，new操作符是用于创建一个给定构造函数的实例对象
- 通过new操作符构造出来的实例可以访问构造函数中的属性
- 通过new操作符构造出来的实例可以访问构造函数原型连中的属性
## 流程
new 操作符主要做了一下工作：
- 创建一个新的对象 object
- 将对象与构造函数通过原型连链接起来
- 将构造函数中的this绑定到新构建的对象object上
- 根据构造函数返回类型作判断，如果是原始值则被忽略，如果事返回对象，需要正常处理
# 手写一个new 功能
```js
function func(funcx,...arg){
  const obj={}
  obj.__proto__=funcx.tyototype
    const s= funcx.apply(obj,arg)
    return s instamceof Object?s:obj
}
```

# AJAX原理，如何实现

## ajax是什么？

- ajax（异步的javascript与XML） 是一种创建交互式网页应用的网页开发技术，可以在不重复加载整个网页的情况下，与服务器进行数据交换，并且更新部分网页
- ajax的原理简单来说就是 通过XmlHttpRequest对象来向服务器发送异步请求，从服务器获得数据，然后用javascript来操作dom更新页面
## 实现过程
  实现ajax异步交互需要服务器逻辑进行配合，需要完成以下步骤：
- 创建Ajax的核心对象XMLHttpRequest对象
- 通过XMLHttpRequest对象的open()方法与服务端进行连接
- 构件请求所需的数据内容，并通过XMLHttpRequest对象的send() 方法发送给服务器端
- 通过XMLHttpRequest对象提供的onreadystatechange事件监听服务器端你的通信状态
- 接受并处理服务端向客户端相应的数据结果
- 将处理结果更新到HTML页面当中
# bind、call、apply的区别
## 作用 
 bind、call、apply的作用都是改变this指向的
## 区别
### apply
- apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入
- 改变this后原函数会立即执行，且此方法只是临时改变this指向一次
```js
function fn(...args){
    console.log(this,args);
}
let obj = {
    myname:"张三"
}

fn.apply(obj,[1,2]); // this会变成传入的obj，传入的参数必须是一个数组；
fn(1,2) // this指向window
```
- 当第一个参数为null、undefined的时候，默认this指向window（浏览器中）
###  call
- call方法的第一个参数也是this的指向，后面传入是一个参数列表
- 跟apply方法一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次
```js
function fn(...args){
    console.log(this,args);
}
let obj = {
    myname:"张三"
}

fn.call(obj,1,2); // this会变成传入的obj，传入的参数必须是一个数组；
fn(1,2) // this指向window
```
- 同样的，当第一个参数为null或者undefined的时候，this就会指向window
### bind
- bind方法和call方法很相似，第一个参数也是this的指向，后面传入的也是一个参数列表（但是这个参数列表可以分多次传入）
- 改变this指向后不会立即执行，而是返回一个永久改变this指向的函数
```js
function fn(...args){
    console.log(this,args);
}
let obj = {
    myname:"张三"
}

const bindFn = fn.bind(obj); // this 也会变成传入的obj ，bind不是立即执行需要执行一次
bindFn(1,2) // this指向obj
fn(1,2) // this指向window
```
###  区别
从上面可以看到 apply、call、bind三者的区别在于：
- 相同点： 
     - 三者都可以改变韩式this的指向
     - 三者第一个参数都是this要指向的对象，如歌没有这个参数或者参数为null、 undefined，则默认指向全局window
- 不同点：
     - 三者都可以穿参，但是apply是数组，而call是参数列表，且apply和call是一次性传入单数，而bind可以分为多次传入
     - bind是返回绑定this之后的函数，apply、call则是立即执行 
# 正则表达式
## 什么是正则表达式？
正则表达式是用来匹配字符串的强有力的规则
- 它的设计思想是一种描述性的语言定义一个规则，凡是符合规则的字符串，我们就认为它匹配了，否则改字符串就是不合法的
在JavaScript中，正则表达式也是对象，构建正则表达式有两种方式：
1. 字面量创建，其由包含在斜杠之间的模式组成  
```js
const re=/\d+/g;
```
2. 调用RegExp对象的构造函数
```js
const re=new RegExp("\\d","g")
const rul='\\d+'
const re1=new RegExp(rul,'g')
```
- 使用构建函数创建，第一个参数可以是一个变量，遇到特殊字符“\”需要使用“\\”进行转义
## 匹配规则

常见的校验规则如下：

| 规则        | 描述                                                  |
| ----------- | ----------------------------------------------------- |
| \           | 转义                                                  |
| ^           | 匹配输入的开始                                        |
| $           | 匹配输入的结束                                        |
| *           | 匹配前一个表达式 0 次或多次                           |
| +           | 匹配前面一个表达式 1 次或者多次。等价于 `{1,}`        |
| ?           | 匹配前面一个表达式 0 次或者 1 次。等价于`{0,1}`       |
| .           | 默认匹配除换行符之外的任何单个字符                    |
| x(?=y)      | 匹配'x'仅仅当'x'后面跟着'y'。这种叫做先行断言         |
| (?<=y)x     | 匹配'x'仅当'x'前面是'y'.这种叫做后行断言              |
| x(?!y)      | 仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找 |
| (?<!*y*)*x* | 仅仅当'x'前面不是'y'时匹配'x'，这被称为反向否定查找   |
| x\|y        | 匹配‘x’或者‘y’                                        |
| `{n}`         | n 是一个正整数，匹配了前面一个字符刚好出现了 n 次     |
| `{n,} `       | n是一个正整数，匹配前一个字符至少出现了n次            |
| `{n,m}`       | n 和 m 都是整数。匹配前面的字符至少n次，最多m次       |
| [xyz\]      | 一个字符集合。匹配方括号中的任意字符                  |
| [^xyz\]     | 匹配任何没有包含在方括号中的字符                      |
| \b          | 匹配一个词的边界，例如在字母和空格之间                |
| \B          | 匹配一个非单词边界                                    |
| \d          | 匹配一个数字                                          |
| \D          | 匹配一个非数字字符                                    |
| \f          | 匹配一个换页符                                        |
| \n          | 匹配一个换行符                                        |
| \r          | 匹配一个回车符                                        |
| \s          | 匹配一个空白字符，包括空格、制表符、换页符和换行符    |
| \S          | 匹配一个非空白字符                                    |
| \w          | 匹配一个单字字符（字母、数字或者下划线）              |
| \W          | 匹配一个非单字字符                                    |

### 正则表达式标记

| 标志 | 描述                                                      |
| :--- | :-------------------------------------------------------- |
| `g`  | 全局搜索。                                                |
| `i`  | 不区分大小写搜索。                                        |
| `m`  | 多行搜索。                                                |
| `s`  | 允许 `.` 匹配换行符。                                     |
| `u`  | 使用`unicode`码的模式进行匹配。                           |
| `y`  | 执行“粘性(`sticky`)”搜索,匹配从目标字符串的当前位置开始。 |

### 贪婪模式
在了解贪婪模式之前，首先举个例子
```js
const reg=/ab{1,3}c/
```
在匹配过程中，尝试可能的顺序是从多往少的方向去尝试，首先会尝试`bbb` ，然后再看整个正则是否能匹配，不能匹配时，吐出一个`b`，即在`bb`的基础上在进行尝试，以此重复

