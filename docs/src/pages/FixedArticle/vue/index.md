# 什么是VUE？ 
- vue是一个用于创建用户界面的JavaScript开源框架，也是一个用于创建单页应用的web应用框架。
  
# vue核心特性

### 数据驱动（MVVM:Model-view-viewModel）
- Model: 模型层，负责处理业务逻辑以及和server端（服务端）进行交互
- View：视图层，负责将数据模型转化为UI界面展示出来
- ViewModel：视图模型层，用来链接Model和View，是Model和View之间的通信桥梁
  
### 组件化 
 把图形和非图形的各种逻辑均抽象出来形成一个统一的概念（组件）来实现开发的模式 
 - 优点：
    * 降低代码的耦合度，提高开发效率
    * 方便调试
    * 提高可维护性
    * 
### 指令系统
  常用的一些vue指令
   - v-if：判断
   - v-show：判断 display
   - v-model：  input实现双向绑定
   - v-for：  循环
   - v-slot：  插槽
   - v-on：  事件
   - v-blind：  双向绑定
   - v-html：  转为html
   - v-text：  转为文本
   - v-pre： 跳过该元素及其子元素的编译
   - v-once：只渲染一次，并跳过之后的更新
   - v-cloak: 用来隐藏尚未编译完成的dom模板
  
# vue和原生开发的区别
- vue所有的界面事件，都只是去操作数据的，原生则是操作dom
- vue所有见面的变动，都是根据数据自动更新出来的，原生的则是操作dom

# vue和React的区别
  - 相同点：
     - 都是组件化开发
     - 都支持服务端渲染 SSR
     - 都有v-dom
     - 数据驱动视图
     - 都对TS友好
     - 单项数据流
  - 不同点：
     - 数据绑定方式  vue是双向数据绑定，react采用单项数据绑定
     - 写法不同，vue更流行sfc组件的写法  react则更偏向jsx写法
     - 粒度不同， vue粒度略粗  react粒度更细
     - 核心思想不同  vue降低门槛，灵活易用   react则是声明式和组件化 

# 什么是SPA？（单页应用）
- spa是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面来回切换打断用户体验。
- 在单页应用中，所有必要的代码都通过单个页面的需要而加载，或者根据需要动态的加载适当的资源到页面，
- 页面在任何时间点都不会完全重新加载，也不会将控制转移到其他页面  
  
### 常见的SPA应用
   - vue、react、angular、ember
### MPA（多页应用）
- 在mpa中，每一个页面都是主页面，都是相对独立的，让我们从一个页面访问另一个页面时，所对应的资源则会全部重新加载
### SPA和MPA的区别 

- 组成： 单页应用由一个主页面和多个页面片段组成，多页应用则是由多个主页面组成
- 刷新方式： spa： 局部刷新    mpa： 全局刷新
- url模式： spa: hash模式    mpa: 历史模式
- SEO优化： spa：难实现，可使用SSR方式改善     mpa：容易实现
- 数据传递： spa：容易          mpa：通过url、cookie、loaclStorage等传递
- 页面切换： 速度快，用户体验好   mpa：切换加载资源，速度慢，用户体验差
- 维护成本： 相对比较容易        mpa：相对比较复杂

### SPA的优缺点
- 优点：
    - 具有桌面应用的即时性、网站的可移植性和访问性
    - 用户体验好、快，内容的改变不需要重新加载整个页面
    - 良好的前后端分离，分工更明确
- 缺点：
    - 不利于搜索引擎的抓取
    - 首次渲染速度相对较慢 

### SPA的实现
- 原理：
    1. 监听地址栏中 **hash**变化驱动界面变化
    2. 用pushstate记录浏览器的历史，驱动界面发生变化
### SPA应用的的SEO优化方式
- SSR服务端渲染
- 静态化
- 使用PhantomJS针对爬虫处理
# v-show和v-if的区别，使用场景分别是什么？
  * 共同点 
    - 当表达式为true时，都会占据页面的位置
    - 当表达式为false时，都不会占据页面的位置
  * 不同点
    - 控制手段不同：v-show 隐藏则是为该元素添加 display：none，dom结构依然存在。 v-if则是将整个dom元素添加或者删除
    - 编译过程不同：v-if的切换有一个局部编译/卸载的过程，切换的过程中合适的销毁和重建内部的事件监听和子组件。  v-show则只是简单的 css切换
    - 编译条件不同：v-if是真正的条件渲染，他会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建
    - v-show改变状态时不会触发组件的生命周期， v-if则会
    - 性能消耗不同，v-show性能开销少， v-if性能开销大
# vue实例在挂载过程中发生了什么？
- new vue的时候会调用_init方法
    - 定义 **$set、$get、$delete、$watch** 等方法
    - 定义**on、$off、$emit、$off**等事件
    - 定义 **_update、$forceUpdate、$destroy**生命周期
- 调用$mount 进行页面的挂载
- 挂载的时候主要是通过 mountComponent 方法
- 定义updateComponent更新函数
- 执行render生成虚拟dom
- _update将虚拟Dom生成真实Dom结构，并渲染到页面中
# VUE生命周期
- setup   所有声明周期执行之前执行的函数 （vue3独有）
- beforeCreate 组件实例被创建之前
- created 组件实例被创建之后
- beforeMount 组件挂载之前
- mounted 组件挂载到实例之后
- beforeUpdate 组件数据发生变化，组件更新之前
- updated 组件数据发生变化，组件更新之后
- beforeDestroy 组件实例销毁之前
- destroyed 组件实例销毁之后
- activated keep-alive缓存的组件激活时
- deactivated keep-alive缓存的组件停用时调用
- errorCaptured 捕获一个来自子孙组件的错误时被调用

# v-for和v-if的优先级

- vue2中，v-for的优先级高于v-if
- vue3中，v-if的优先级高于v-for 

# SPA首屏加载缓慢
- 原因： 
    - 网络延迟大
    - 文件资源体积过大
    - 资源重复进行加载
    - 加载脚本时，渲染内容阻塞
- 解决方案
    - 减小入口文件体积
    - 静态资源本地缓存
    - Ui框架按需加载
    - 图片资源的压缩
    - 组件尽量重复利用
    - 使用SSR
    - 使用CDN
# 为什么data属性是一个函数而不是一个对象？
  - vue实例在定义data属性的时候既可以是一个对象也可以是一个函数，因为是根实例对象，所以不会产生数据污染的情况
  - 组件中定义data只能是一个函数，目的是为了防止多个组件实例公用一个data对象，从而产生数据的污染，而采用函数形式  initdata时会将其作为工厂函数返回一个全新的data对象
# 在vue中动态的给一个对象中添加属性 界面不刷新 (只存在vue2)
- 原因：
     - vue的双向绑定本质是通过object.definedProperty 所以我们如果直接添加新属性则不会触发这个函数，就无法实现双向数据绑定
     - vue3本质上是通过proxy代理来实现的，如果添加的话也是需要进行.value才能添加，一旦进行.value 那么就会被proxy进行代理
- 解决方案
    - Vue.set()
    - Object.assign()
    - $forceUpdated()
# vue中组件和插件的区别
### 什么是组件
- 组件就是把图形和非图形的各种逻辑均抽象为一个统一的概念来实现的开发方式，在vue中，每一个.vue文件都可以视作是一个组件
    - 组件的优势：
        - 降低耦合度，减少代码量
        - 调试方便，能更快速定位问题
        - 提高系统的可维护性
### 什么是插件
- 插件通常用来为vue添加全局功能，插件的功能范围没有严格的限制 例如一下几种： 
    - 添加全局方法或属性
    - 添加全局资源
    - 通过全局混入来添加一些组件选项，如vue-router
    - 添加多个vue实例方法，通过把他们添加到vue.prototype 上实现
### 区别：
  - 编写形式：组件主要是.vue为主 插件则不限制，并且插件应该暴露一个方法install，方法的第一个参数是一个vue构造器，第二个参数是一个可选的选项对象
  - 注册形式：vue组件的注册方式主要有两种：全局注册和局部注册，插件注册的方式主要是通过vue.use()的方式进行注册 注意：vue注册插件的时候，需要再new vue()之前完成，vue.use会自动组织多次注册相同插件，只会注册一次
  - 使用场景：组件主要是用来构成你的业务模块的，他的目标是App.vue  插件主要是用来增强你的技术栈的功能模块，他的目标是vue本身
# vue组件之间的通信方式有哪些？
- 通过props传递
- 通过$emit来触发事件
- 使用ref
- EventBus
- $parent或$root
- attrs与listeners
- provide与inject
- vueX
### 组件通信的分类
- 父子组件之间的通信   可选择props和$emit 也可以选择ref
- 兄弟组件之间的通信   可选择$bus 其次可以选择$parent进行传递
- 祖孙与后代组件之间的通信  可选择attrs与listeners或者Provide与inject
- 非关系组件之间的通信   可以直接选择vuex或者pinia

# 双向绑定
### 什么是双向绑定
- 双向绑定是指数据模型和视图之间的同步更新机制。当数据模型发生变化时，视图会自动更新，反之，当视图当中的数据发生变化时，数据模型也会自动更新，这种机制主要是通过v-model进行实现的，比较常用在表单控件上
### 双向绑定的原理
1. 数据监听：vue使用object.defineProperty(vue2)或者是proxy（vue3），来劫持数据的读写操作，从而实现数据的响应式
2. 模板编译：vue模板编译器会解析模板中的vue指令，如v-module并生成相对应的渲染函数，一旦数据发生变化，便会重新执行相对应的渲染函数，来更新虚拟dom
3. 虚拟dom：当数据发生变化时vue通过虚拟dom计算出最小的变化量，并高效的更新真实的dom
4. 事件监听：vue会自动为双向绑定的表单控件添加事件监听器，当用户在视图上进行操作时，事件监听器会更新数据模型
### 双向绑定的核心
- vue双向绑定的核心就是mvvm
   1. new vue() 首先执行初始化，对data执行响应式处理，这个过程发生在Observer中
   2. 同时对模板执行编译，找到其中的动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中
   3. 同时定义一个更新函数和watcher，将来应对数据变化时watcher会调用更新函数
   4. 由于data的某一个key可能会一个视图中多次出现，所以每一个key都需要一个管家Dep来管理多个watcher
   5. 将来data中的数据一旦发生变化，就会找到相对应的Dep，通知说有的watcher进行更新
# 谈谈你对NextTick的理解
### 什么是NextTick？
- 在下次dom更新循环结束之后执行，在修改数据之后立刻执行这个方法，获取更新之后的dom
### slot
### slot 是什么
-   slot是插槽，作为web components技术套件的一部分 是web组件内一个占位符，该占位符可以在后期使用自己的标记语言进行填充
### 使用场景
- 可以浅显的理解为是一个“龟壳”或者是shell，在一些具有部分功能和样式相似的页面中，而内部只有一部分或者小部分不同，这个时候就可以使用插槽，来指定这部分相同的内容，而不同的部分最后可以直接嵌入到插槽内来实现
- 例如: message，外部的样式基本相同，内部只有提示信息和按钮略有不同，这个时候就可以配合插槽以及一些指定封装的组件来进行实现
### 分类
 - 默认插槽 默认插槽本质上也是一个具名插槽 name名称为 default
 - 具名插槽
 - 作用域插槽  子组件在作用域上绑定属性来将子组件的属性传递到父组件中进行使用，这些属性会被挂载在父组件的v-slot接受的对象上，父组件在使用时通过v-slot(简写为 #)获取子组件信息，在内容中进行使用
# vue.observable
### 作用
- 可以让一个数据变成响应式，主要是用来在不需要组件的情况下，创建可响应的全局状态
- 在Vue3中 vue.observable被reactive所取代

# vue中 key的作用
### key是什么
- key是给每一个vnode节点添加的唯一id，也是diff的一种优化策略。可以根据key来更快速更准确的找到对应的vnode节点

### 逻辑
当我们使用v-for时，需要给单元加上key
- 如果不使用key，vue会采用**就地复用原则**：最小化element的移动，并且会尝试在尽最大程度在适当的地方对相同类型的element，做path或者reuse
- 如果使用了key，vue会根据使用的keys的顺序记录element，曾经拥有了key的element如果不再出现的话，会被直接remove或者destoryed
- 如果使用new date()，生成时间戳来作为key的话，则会触发强制渲染
- 当拥有新值的render作为key时，拥有新key的comp出现了，那么旧的 comp会被移除，新comp触发渲染

# keep-alive 缓存
### 什么是keep-alive
- keep-alive是vue中的内置组件，能在组件进行切换过程中将状态保留在内存当中，防止重复渲染dom和数据
- keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们
- keep-alive可以设置一下props属性：
   - include ：字符串或正则表达式，只有名称匹配的组件才会被缓存
   - exclude ：字符串或正则表达式，名称被匹配的组件永远不会被缓存 
   - max：数字，最多可以缓存多少个组件实例
### 使用场景
- 当页面需要缓存时
- 当页面频繁加载不变的数据时
- 当页面不需要重新加载时
# vue常用的修饰符有哪些？有什么应用场景
### 什么是修饰符
- 修饰符是用于限定类型以及类型成员的声明的一种符号
### vue的修饰符分为以下五种
* 表单修饰符
* 事件修饰符
* 鼠标按键修饰符
* 键盘修饰符
* v-bind修饰符
###### 表单修饰符
- lazy  在我们填完信息，光标离开标签的时候才会赋值给 value 也就是在onchange事件之后
- trim  自动过滤用户输入的首位空格，中间的空格不会过滤
- number 自动将用户输入的值转换为number类型，但是如果输入的值不能被parseFloat解析，则会返回原来的值
###### 事件修饰符
* stop：阻止了冒泡事件，相当于调用了event.stopPropagation方法
* prevent：阻止了事件的默认行为，相当于调用了event.PreventDefault 方法
* self：只在当前元素自身时触发
* once：只会触发一次
* captrue：使事件触发从这个元素包含的顶层，从上往下开始触发
* passive：在移动端，当我们监听元素滚动事件的时候会一直触发onscroll事件，从而使得网页卡顿，使用passive 就是相当于添加了 lazy修饰符
     - 注意：不要把prevent和passive一起使用，因为prevent会被忽略，同时，浏览器会发出警告
* native：让组件变得像html内置标签那样监听根元素的原生事件，否则组件上使用v-on 只会监听自定义事件
###### 鼠标按钮修饰符
* left：点击鼠标左键
* right：点击鼠标右键
* middle：点击鼠标中键
###### 键盘修饰符
键盘修饰符是用来修饰键盘事件（onkeydown和onkeyup）
* keycode有很多 ，但vue为我们提供了一些别名，主要分为以下两种
   - 普通键（enter、tab、delete、space、esc、up...）
   - 系统修饰键（ctrl、alt、meta、shift...）
###### v-bind修饰符
* async 能对props的数据进行一个双向数据绑定  但是需要注意：
    -  使用async的时候，子组件传递的事件名必须为 update:value，其中value必须与子组件中props中声明的名称完全一致
    -  注意带有 .async修饰符的v-bind不能和表达式一起使用
    -  将v-bind.async用在一个字面量的对象上，例如 v-bind.async="{title:doc.title}" 是无法正常工作的
* prop ：设置自定义标签属性，避免数据暴露，防止污染Html结构
* camel：将命名变为驼峰命名法
# 自定义指令
### 什么是指令
- 指令是计算机硬件的语言系统，也叫机器语言，它是系统程序员看到计算机的主要属性，因此指令系统表现了计算机的基本功能，决定了及其所要求的能力
- vue为我们提供了一套为数据驱动视图更为方便的操作，这些操作被称为指令系统，我们看到的**v-**开头的行内属性都是指令，不同的指令可以完成或实现不同的功能
- 除了核心功能默认的指令，vue也允许自定义指令
### 如何实现一个自定义指令
注册一个指令分为两种：全局自定义指令和局部自定义指令
- 全局注册 主要是通过Vue.directive方法进行注册 第一个参数是指令名称，不需要带上v-前缀，第二个参数可以是对象数据，也可以是一个指令函数
- 局部注册，可以通过设置directives    在vue3中 如果使用了**srcipt setup**则任何以v开头的驼峰式命名的变量都可以被作用于一个自定义指令
### 自定义指令也想组件一样存在一些钩子函数
- bind：只调用一次，指令第一次绑定到元素上时调用，这里可以进行一些初始化设置
- inserted：被绑定的元素插入父节点时调用
- update：所在组件的v-node更新时调用，但是可能发生在其子v-node更新之前
- componentUpdated：指令所在的vnode及其子vnode全部更新后调用
- unbind：只调用一次，指令与元素解绑时调用
  
所有的钩子都有以下参数
* el：指令绑定的元素，可以直接用来操作dom
* binding：一个对象，包含以下参数
    * name：指令名称，不包含 **v-** 前缀 
    * value：指令的绑定值
    * oldValue：指令绑定的签一个值
    * expression：字符串形式的指令表达式
    * arg：传递给指令的参数，可选
    * modifiers：一个包含修饰符的对象
    * vnode：vue编译生成的虚拟节点
    * oldVnode: 上一个虚拟节点
### 使用场景
* 方式表单重复提交 (实际上就是做一个防抖)
* 一键copy功能
* 页面水印
# 虚拟dom 
### 什么是虚拟dom
- 虚拟dom只是一层对真是dom的抽象，以js对象（vnode节点）作为基础的树，用对象的属性来描述节点，最终通过一系列操作将这个对象映射到真是的dom节点上
- 在js对象中，虚拟dom表现为一个object对象，并且至少包含签名（tag），属性（attrs）和子元素（children）三个属性，不同框架对于这三者的名称可能有些许差别
- 创建虚拟dom就是为了更好的将虚拟的节点渲染到页面视图中，所以虚拟dom中的节点与真是dom中的节点一一对应
### 为什么需要虚拟dom
- 真实的dom节点很慢，其元素非常庞大，页面中的绝大多数性能问题，本质上都是由操作dom节点引起的
例如：
- 当你利用传统api或者jq来操作原生dom时，浏览器会从构建dom开始从头到尾执行一遍流程 ：当你在一次操作时，需要更新十个dom节点，浏览器没那么只能，收到第一个更新dom的请求后，本身并不知道后续还有9次更新操作，因此会马上执行流程，最终会执行十次流程
- 而通过Vnode，同样更新十个dom节点，虚拟dom并不会立即操作dom，而是将这十次更新的diff内容保存到本地的一个js对象中，最终这个js对象将会一次性attach到dom树上，避免大量的无谓计算
   - ps:很多人认为虚拟dom最大的优势是diff算法，减少js操作真是dom所带来的性能消耗，虽然这确实是虚拟dom所带来的一个优势，但是并不是全部，虚拟dom最大的优势是在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅只局限于浏览器的dom，可以是安卓和ios的原生组件，可以是近期很火热的小程序，也可以是各种GUI
# vue的diff算法
### diff算法是什么？
- diff算法是一种通过同层树节点进行比较的高效算法，其具有以下两个特点：
    - 比较只会在同级进行，不会跨级比较
    - 在diff比较过程中，循环从两边向中间比较
- diff算法在很多场景下都有应用，在vue中作用域虚拟dom渲染成真实dom的新旧vnode 节点比较
### diff算法的比较方式
diff整体策略为： 深度优先，同级比较
1. 比较只会在同级进行不会跨层级比较
2. 比较过程中，循环会从两边向中间收拢
### 原理分析
当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的dom打补丁，更新响应的视图
- patch函数前两个参数为 oldVnode和Vnode，分别代表新节点和旧的节点，主要做了以下四个判断
    - 没有新节点，直接触发旧节点的destory钩子
    - 没有旧节点，说明页面是刚开始初始化，根本不需要比较，直接调用createElement
    - 旧节点和新节点自身一致，通过sameVnode判断节点 是否一样，一样时，直接调用patchVnode去处理这两个节点
    - 旧节点和新节点自身不一样，当发现两个节点不一致时，直接创建新节点，然后删除旧节点
- pathVnode的操作： 会进行如下几个判断
     - 新节点是否是文本节点，如果是文本节点，则直接更新dom的文本节点内容为新节点的文本内容
     - 新节点和旧节点是否都有子节点，则处理比较，更新子节点
     - 只有新节点有子节点，旧节点没有子节点，那么不用比较，直接，那么将全部新建子节点。新建是指全部创建出所有新的dom，并添加进父节点
     - 只有旧节点有子节点，新节点没有子节点，那么就会删除所有旧节点，创建新的节点
- 子节点如果完全不一致，则调用updateChildren
- while循环主要处理了以下五中情景：
     - 当新老Vnode节点start 相同时，直接patchVnode，同时新老节点的开始索引都+1
     - 当新老vnode节点end相同时，也直接patchVnode,同时新老节点的结束索引都-1
     - 当老Vnode节点的satrt与新Vnode节点的end相同时，直接进行patchVnode，同时还需要将当前真实dom节点移动到oldEndVnode的后面，并且老Vnode节点索引+1 新Vnode节点索引-1
     - 当老Vnode节点的end与新Vnode节点的start相同时，直接进行patchVnode，同时还需要将当前真实dom节点移动到oldStartVnode的前面，并且老Vnode节点索引-1 新Vnode节点索引+1
     - 如果都不满足以上四种情形，那么就说明没有相同的节点可以复用，则会分为以下两种情况
         - 从旧的Vnode为key值，对应index序列为value值的哈希表中找到newStartVnode一致key的旧Vnode的节点，再进行patchVnode，同时将这个真是dom的实力移动到oldStartVnode对应的真实dom的前面
         - 调用createElem创建一个新的dom节点放到当前newStartIdx的位置
# axios
### 什么是axios
- axios是一个轻量的http客户端，是基于XMLHttpRequest服务来执行http请求，支持丰富的配置，支持promise，支持浏览器端和nodeJS端，
### 特性
- 从浏览器创建XMLHttpRequest
- 从nodeJS端创建http请求
- 支持Promise API
- 拦截请求和响应
- 转换请求数据和相应数据
- 取消请求
- 自动转换json数据
- 客户端支持防御XSRF
### 为什么要封装axios？
- 因为每个业务的差异比较大，并且大多数请求，都涉及请求头，超时时间，环境地址等因素，如果我们一个一个去设置，会过于麻烦，违背了高内聚弱耦合的的原则

# SSR 
### SSR是什么
- server-side rendering 简称ssr （服务端渲染） 是指由服务侧完成页面的html结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态和事件，成为完全可交互页面的过程
### web页面渲染的发展史
- 传统服务端渲染SSR：网页的所有内容在服务端完成渲染，然后一次性传输到浏览器，缺点：由于全在服务端渲染，那么对于服务器的压力比较大
- 单页面应用SPA：页面完全交由浏览器进行页面渲染，缺点:因为一开始需要加载很多内容，所以很容易导致首屏页面渲染时间过长，
- 服务端渲染SSR：页面首屏会交由服务器端进行渲染，浏览器拿到拿到的内容包括首屏以及完整的spa结构，应用激活后依旧按照spa的方式进行，缺点：需要单独学习ssr技术，比较考验技术水平
### vue SSR
- VUE SSR是一个在SPA上进行改良的服务端渲染
- 通过VUE SSR渲染的页面，需要在客户端激活才能使用
- VUE SSR会包含两部分，服务端渲染的首屏，包含交互的SPA
### 为什么使用SSR
- 利于SEO优化：搜索引擎优先爬取页面的HTML结构，使用SSR时，服务端已经生成了和业务相关联的HTML结构，有利于SEO的优化
- 首屏呈现渲染：用户无需等待所有页面的js加载完成就可以看到整个页面的视图
- 缺点：
     - 复杂度增高：整个项目的复杂度会比单独使用spa要高一些
     - 库的支持性，代码兼容
     - 性能问题：
         - 每一个请求都是n个实例的创建 ，不然会污染，消耗变得很大
         - 降级: 监控cpu、内存占用过多，就spa，返回单个的壳
     - 服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器的负载会更大
# 权限管理
前端权限控制可以分为四个方面
- 接口权限
- 按钮权限
- 菜单权限
- 路由权限

##### 接口权限
 接口权限目前一般主要采用jwt形式来验证 ，没有通过的话一般返回401，跳转到登陆页面重新进行登陆，登录完成拿到token，然后存储起来，在每次请求的时候将token携带到请求头内
##### 路由权限控制
- 方案一：初始化即挂载全部路由，并在路由上标记相对应的权限信息，每次路由跳转前做一次权限校验
     - 缺点：
          1. 加载所有的路由，加载的路由会很多，而用户并不是所有路由都有权限访问，那么就会对性能有一些影响
          2. 全局路由守卫里，每次跳转都需要做一次权限判断 
          3. 菜单信息写死在前端，如果需要更改显示文字或者路由信息，就需要重新进行编译
          4. 菜单跟路由耦合在一起的话，定义路由的时候，还要添加菜单的标题，图标等等之类的信息，但是路由不一定作为菜单显示，那么就需要多加字段进行标识了
- 方案二：初始化的时候不挂载全部路由，只挂在不要权限的路由，例如登陆，404页面等，如果用户通过修改url进行强制访问，那么会被引导到404页面，这相当于从源头上做了控制，登陆后，获取用户权限信息，然后匹配相对应的路由，通过addRoutes方法来进行路由添加
     - 缺点：
         1. 全局路由守卫里，每一次跳转都需要做判断
         2. 菜单信息写死在前端，如果需要更改显示文字或路由信息，需要重新进行编译
         3. 菜单跟路由耦合在一起的话，定义路由的时候，还要添加菜单的标题，图标等等之类的信息，但是路由不一定作为菜单显示，那么就需要多加字段进行标识了
##### 菜单权限
菜单权限可以理解成将页面和路由进行解偶
- 方案一：菜单与路由分离，菜单由后端进行返回 前端来定义路由信息
     - 缺点：
          1. 菜单与路由需要一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不正确，就会导致某些功能无法正常使用
          2. 全局路由守卫，每次跳转都需要做一次判断
- 方案二：菜单和路由都由后端进行返回，前端统一定义路由组件
     - 缺点：
         1. 对于前后端的配合要求更高了   
         2. 全局路由守卫，每次跳转都需要做一次判断
##### 按钮权限
- 方案一： 通过v-if来进行判断，但是如果页面过多，每个页面都要获取用户权限role和路由表里的meta.btnPermissions,然后再做判断
- 方案二：通过自定义指令进行按钮权限判断，在使用的按钮中只需要通v-has
# 跨域
### 什么是跨域
- 跨域的先决条件是浏览器端才会出现的问题，如果是服务端对服务端，不会出现这个问题
- 跨域的条件是必须违背同源策略：端口、域名、协议、三者只要有任意一项不符合，都属于跨域。
### 如何解决
- jsonp
- Cors :后端设置响应头 Access-Control-Allow-Origin为host
- proxy：服务器代理，三种方式：
      1. 如果我们的项目是通过脚手架构建的，那么实际上我们可以通过webpack在本机起一个本地服务器作为请求的代理对象
      2. 通过服务端进行请求代理转发
      3. 通过配置nginx实现代理  

# Vue3和vue2的区别
- 速度更快
- 体积更小
- 更易维护
- 更接近原生
- 更易使用
### 速度更快
vue3相比较vue2：
- 重写了虚拟dom的视线
- 编译模板的优化
- 更高效的组件初始化
- undate性能提高1.3~2倍
- SSR速度提高了2~3倍
### 体积更小
- 通过three-shaking，实现了按需加载，减少了打包的代码体积
### 更易维护
实现了compositon API
- 可以与现有的options api一起使用
- 灵活的逻辑组合和复用
- vue3模块可以搭配其他框架使用
- 更好地对ts的支持
### 更接近原生
- 可以自定义渲染API
### 更易使用
- 响应式api暴露出来

# vue3 新特性
- framents 多个根组件
- Teleport Teleport 是一种能够将我们的模板移动到 DOM 中 Vue app 之外的其他位置的技术
- createRender 能够构建自定义渲染器，我们能够将 vue 的开发模型扩展到其他平台  我们可以将其生成在canvas画布上
- composition Api 更加容易维护我们的代码，将相同功能的变量进行一个集中式的管理


   
       
  
  