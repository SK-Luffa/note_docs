# 什么是VUE？ 
- vue是一个用于创建用户界面的JavaScript开源框架，也是一个用于创建单页应用的web应用框架。
  
# vue核心特性

### 数据驱动（MVVM:Model-view-viewModel）
- Model: 模型层，负责处理业务逻辑以及和server端（服务端）进行交互
- View：视图层，负责将数据模型转化为UI界面展示出来
- ViewModel：视图模型层，用来链接Model和View，是Model和View之间的通信桥梁
  
### 组件化 
 把图形和非图形的各种逻辑均抽象出来形成一个统一的概念（组件）来实现开发的模式 
 - 优点：
    * 降低代码的耦合度，提高开发效率
    * 方便调试
    * 提高可维护性
    * 
### 指令系统
  常用的一些vue指令
   - v-if：判断
   - v-show：判断 display
   - v-model：  input实现双向绑定
   - v-for：  循环
   - v-slot：  插槽
   - v-on：  事件
   - v-blind：  双向绑定
   - v-html：  转为html
   - v-text：  转为文本
   - v-pre： 跳过该元素及其子元素的编译
   - v-once：只渲染一次，并跳过之后的更新
   - v-cloak: 用来隐藏尚未编译完成的dom模板
  
# vue和原生开发的区别
- vue所有的界面事件，都只是去操作数据的，原生则是操作dom
- vue所有见面的变动，都是根据数据自动更新出来的，原生的则是操作dom

# vue和React的区别
  - 相同点：
     - 都是组件化开发
     - 都支持服务端渲染 SSR
     - 都有v-dom
     - 数据驱动视图
     - 都对TS友好
     - 单项数据流
  - 不同点：
     - 数据绑定方式  vue是双向数据绑定，react采用单项数据绑定
     - 写法不同，vue更流行sfc组件的写法  react则更偏向jsx写法
     - 粒度不同， vue粒度略粗  react粒度更细
     - 核心思想不同  vue降低门槛，灵活易用   react则是声明式和组件化 

# 什么是SPA？（单页应用）
- spa是一种网络应用程序或网站的模型，它通过动态重写当前页面来与用户交互，这种方法避免了页面来回切换打断用户体验。
- 在单页应用中，所有必要的代码都通过单个页面的需要而加载，或者根据需要动态的加载适当的资源到页面，
- 页面在任何时间点都不会完全重新加载，也不会将控制转移到其他页面  
  
### 常见的SPA应用
   - vue、react、angular、ember
### MPA（多页应用）
- 在mpa中，每一个页面都是主页面，都是相对独立的，让我们从一个页面访问另一个页面时，所对应的资源则会全部重新加载
### SPA和MPA的区别 

- 组成： 单页应用由一个主页面和多个页面片段组成，多页应用则是由多个主页面组成
- 刷新方式： spa： 局部刷新    mpa： 全局刷新
- url模式： spa: hash模式    mpa: 历史模式
- SEO优化： spa：难实现，可使用SSR方式改善     mpa：容易实现
- 数据传递： spa：容易          mpa：通过url、cookie、loaclStorage等传递
- 页面切换： 速度快，用户体验好   mpa：切换加载资源，速度慢，用户体验差
- 维护成本： 相对比较容易        mpa：相对比较复杂

### SPA的优缺点
- 优点：
    - 具有桌面应用的即时性、网站的可移植性和访问性
    - 用户体验好、快，内容的改变不需要重新加载整个页面
    - 良好的前后端分离，分工更明确
- 缺点：
    - 不利于搜索引擎的抓取
    - 首次渲染速度相对较慢 

### SPA的实现
- 原理：
    1. 监听地址栏中 **hash**变化驱动界面变化
    2. 用pushstate记录浏览器的历史，驱动界面发生变化
### SPA应用的的SEO优化方式
- SSR服务端渲染
- 静态化
- 使用PhantomJS针对爬虫处理
# v-show和v-if的区别，使用场景分别是什么？
  * 共同点 
    - 当表达式为true时，都会占据页面的位置
    - 当表达式为false时，都不会占据页面的位置
  * 不同点
    - 控制手段不同：v-show 隐藏则是为该元素添加 display：none，dom结构依然存在。 v-if则是将整个dom元素添加或者删除
    - 编译过程不同：v-if的切换有一个局部编译/卸载的过程，切换的过程中合适的销毁和重建内部的事件监听和子组件。  v-show则只是简单的 css切换
    - 编译条件不同：v-if是真正的条件渲染，他会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建
    - v-show改变状态时不会触发组件的生命周期， v-if则会
    - 性能消耗不同，v-show性能开销少， v-if性能开销大
# vue实例在挂载过程中发生了什么？
- new vue的时候会调用_init方法
    - 定义 **$set、$get、$delete、$watch** 等方法
    - 定义**on、$off、$emit、$off**等事件
    - 定义 **_update、$forceUpdate、$destroy**生命周期
- 调用$mount 进行页面的挂载
- 挂载的时候主要是通过 mountComponent 方法
- 定义updateComponent更新函数
- 执行render生成虚拟dom
- _update将虚拟Dom生成真实Dom结构，并渲染到页面中
# VUE生命周期
- setup   所有声明周期执行之前执行的函数 （vue3独有）
- beforeCreate 组件实例被创建之前
- created 组件实例被创建之后
- beforeMount 组件挂载之前
- mounted 组件挂载到实例之后
- beforeUpdate 组件数据发生变化，组件更新之前
- updated 组件数据发生变化，组件更新之后
- beforeDestroy 组件实例销毁之前
- destroyed 组件实例销毁之后
- activated keep-alive缓存的组件激活时
- deactivated keep-alive缓存的组件停用时调用
- errorCaptured 捕获一个来自子孙组件的错误时被调用

# v-for和v-if的优先级

- vue2中，v-for的优先级高于v-if
- vue3中，v-if的优先级高于v-for 

# SPA首屏加载缓慢
- 原因： 
    - 网络延迟大
    - 文件资源体积过大
    - 资源重复进行加载
    - 加载脚本时，渲染内容阻塞
- 解决方案
    - 减小入口文件体积
    - 静态资源本地缓存
    - Ui框架按需加载
    - 图片资源的压缩
    - 组件尽量重复利用
    - 使用SSR
    - 使用CDN
# 为什么data属性是一个函数而不是一个对象？
  - vue实例在定义data属性的时候既可以是一个对象也可以是一个函数，因为是根实例对象，所以不会产生数据污染的情况
  - 组件中定义data只能是一个函数，目的是为了防止多个组件实例公用一个data对象，从而产生数据的污染，而采用函数形式  initdata时会将其作为工厂函数返回一个全新的data对象
# 在vue中动态的给一个对象中添加属性 界面不刷新 (只存在vue2)
- 原因：
     - vue的双向绑定本质是通过object.definedProperty 所以我们如果直接添加新属性则不会触发这个函数，就无法实现双向数据绑定
     - vue3本质上是通过proxy代理来实现的，如果添加的话也是需要进行.value才能添加，一旦进行.value 那么就会被proxy进行代理
- 解决方案
    - Vue.set()
    - Object.assign()
    - $forceUpdated()
# vue中组件和插件的区别
### 什么是组件
- 组件就是把图形和非图形的各种逻辑均抽象为一个统一的概念来实现的开发方式，在vue中，每一个.vue文件都可以视作是一个组件
    - 组件的优势：
        - 降低耦合度，减少代码量
        - 调试方便，能更快速定位问题
        - 提高系统的可维护性
### 什么是插件
- 插件通常用来为vue添加全局功能，插件的功能范围没有严格的限制 例如一下几种： 
    - 添加全局方法或属性
    - 添加全局资源
    - 通过全局混入来添加一些组件选项，如vue-router
    - 添加多个vue实例方法，通过把他们添加到vue.prototype 上实现
### 区别：
  - 编写形式：组件主要是.vue为主 插件则不限制，并且插件应该暴露一个方法install，方法的第一个参数是一个vue构造器，第二个参数是一个可选的选项对象
  - 注册形式：vue组件的注册方式主要有两种：全局注册和局部注册，插件注册的方式主要是通过vue.use()的方式进行注册 注意：vue注册插件的时候，需要再new vue()之前完成，vue.use会自动组织多次注册相同插件，只会注册一次
  - 使用场景：组件主要是用来构成你的业务模块的，他的目标是App.vue  插件主要是用来增强你的技术栈的功能模块，他的目标是vue本身
# vue组件之间的通信方式有哪些？
- 通过props传递
- 通过$emit来触发事件
- 使用ref
- EventBus
- $parent或$root
- attrs与listeners
- provide与inject
- vueX
### 组件通信的分类
- 父子组件之间的通信   可选择props和$emit 也可以选择ref
- 兄弟组件之间的通信   可选择$bus 其次可以选择$parent进行传递
- 祖孙与后代组件之间的通信  可选择attrs与listeners或者Provide与inject
- 非关系组件之间的通信   可以直接选择vuex或者pinia

# 双向绑定
### 什么是双向绑定
- 双向绑定是指数据模型和视图之间的同步更新机制。当数据模型发生变化时，视图会自动更新，反之，当视图当中的数据发生变化时，数据模型也会自动更新，这种机制主要是通过v-model进行实现的，比较常用在表单控件上
### 双向绑定的原理
1. 数据监听：vue使用object.defineProperty(vue2)或者是proxy（vue3），来劫持数据的读写操作，从而实现数据的响应式
2. 模板编译：vue模板编译器会解析模板中的vue指令，如v-module并生成相对应的渲染函数，一旦数据发生变化，便会重新执行相对应的渲染函数，来更新虚拟dom
3. 虚拟dom：当数据发生变化时vue通过虚拟dom计算出最小的变化量，并高效的更新真实的dom
4. 事件监听：vue会自动为双向绑定的表单控件添加事件监听器，当用户在视图上进行操作时，事件监听器会更新数据模型
### 双向绑定的核心
- vue双向绑定的核心就是mvvm
   1. new vue() 首先执行初始化，对data执行响应式处理，这个过程发生在Observer中
   2. 同时对模板执行编译，找到其中的动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中
   3. 同时定义一个更新函数和watcher，将来应对数据变化时watcher会调用更新函数
   4. 由于data的某一个key可能会一个视图中多次出现，所以每一个key都需要一个管家Dep来管理多个watcher
   5. 将来data中的数据一旦发生变化，就会找到相对应的Dep，通知说有的watcher进行更新
  








   
       
  
  